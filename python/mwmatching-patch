diff --git a/python/mwmatching.py b/python/mwmatching.py
index d01667e..16170ef 100644
--- a/python/mwmatching.py
+++ b/python/mwmatching.py
@@ -23,13 +23,80 @@ to validate this new code.
 #
 
 from __future__ import print_function
+import json
+import copy
+import random
+
+
+OUTPUT_DIR = "../test/resources/"
+call_no=0
+instance_id=0
+log = []
+EXPORT_LOGS = True
+
+def log_fn_call(name, context, args):
+    global call_no
+    call_no+=1
+    if EXPORT_LOGS:
+        log.append({"function": name,
+                    "type": "fn-call",
+                    "id": call_no,
+                    "context":copy.deepcopy(context),
+                    "args":copy.deepcopy(args)})
+    return call_no
+
+def log_intermediate(name, call_no, context, user):
+    if EXPORT_LOGS:
+        log.append({"function":name,
+                    "type": "intermediate",
+                    "id":call_no,
+                    "context":copy.deepcopy(context),
+                    "user": user})
+
+def log_return_procedure(name, call_no, context, user = {} ):
+    if EXPORT_LOGS:
+        log.append({"function":name,
+                    "type": "return-procedure",
+                    "id":call_no,
+                    "context":copy.deepcopy(context),
+                    "ret":None,
+                    "user":user})
+
+def log_return_fn(name, call_no, context, ret, user = {} ):
+    if EXPORT_LOGS:
+        log.append({"function":name,
+                    "type": "return-function",
+                    "id":call_no,
+                    "context":copy.deepcopy(context),
+                    "ret":ret,
+                    "user":user})
+    
+def write_log(fn, clear_after=True):
+    global log
+    if EXPORT_LOGS:
+        with open(fn, 'w') as outfile:
+            json.dump(log, outfile, sort_keys=True, indent=2)
+        if clear_after:
+            log = []
+
+def get_fn_call(id):
+    return list(filter(lambda x : x.get("id") == id, log))
+
+def complete_graph(n):
+    nedge = sum([i for i in range(n)])
+    ret = []
+    for i in range(n-1):
+        for j in range(i+1, n):
+            wt = random.randint(0, nedge - 1)
+            ret.append([i, j, wt])
+    return ret
 
 # If assigned, DEBUG(str) is called with lots of debug messages.
 DEBUG = None
-"""def DEBUG(s):
-    from sys import stderr
-    print('DEBUG:', s, file=stderr)
-"""
+# def DEBUG(s):
+#     from sys import stderr
+#     print('DEBUG:', s, file=stderr)
+
 
 # Check delta2/delta3 computation after every substage;
 # only works on integer weights, slows down the algorithm to O(n^4).
@@ -66,6 +133,7 @@ def maxWeightMatching(edges, maxcardinality=False):
     # the paper by Galil; read the paper before reading this code.
     #
 
+    
     # Python 2/3 compatibility.
     from sys import version as sys_version
     if sys_version < '3':
@@ -191,6 +259,36 @@ def maxWeightMatching(edges, maxcardinality=False):
     # Queue of newly discovered S-vertices.
     queue = [ ]
 
+
+    def context ():
+        if EXPORT_LOGS:
+            return { "edges": copy.deepcopy(edges),
+                     "nedge": nedge,
+                     "nvertex": nvertex,
+                     "endpoint": copy.deepcopy(endpoint),
+                     "neighbend": copy.deepcopy(neighbend),
+                     "max-cardinality":bool(maxcardinality),
+                     "mate": copy.deepcopy(mate),
+                     "label": copy.deepcopy(label),
+                     "label-end":copy.deepcopy(labelend),
+                     "in-blossom":copy.deepcopy(inblossom),
+                     "blossom-parent":copy.deepcopy(blossomparent),
+                     "blossom-childs":copy.deepcopy(blossomchilds),
+                     "blossom-base":copy.deepcopy(blossombase),
+                     "blossom-endps":copy.deepcopy(blossomendps),
+                     "best-edge":copy.deepcopy(bestedge),
+                     "blossom-best-edges":copy.deepcopy(blossombestedges),
+                     "unused-blossoms":copy.deepcopy(unusedblossoms),
+                     "dual-var":copy.deepcopy(dualvar),
+                     "allow-edge":copy.deepcopy(allowedge),
+                     "queue":copy.deepcopy(queue)}
+        else:
+            return {}
+
+
+    call_id=log_fn_call("maxWeightMatching", context(), {'edges': edges,
+                                                         'maxcardinality':maxcardinality})
+    
     # Return 2 * slack of edge k (does not work inside blossoms).
     def slack(k):
         (i, j, wt) = edges[k]
@@ -212,6 +310,9 @@ def maxWeightMatching(edges, maxcardinality=False):
     # and record the fact that w was reached through the edge with
     # remote endpoint p.
     def assignLabel(w, t, p):
+        call_id=log_fn_call("assignLabel", context(), {"w":w,
+                                                       "t":t,
+                                                       "p":p})
         if DEBUG: DEBUG('assignLabel(%d,%d,%d)' % (w, t, p))
         b = inblossom[w]
         assert label[w] == 0 and label[b] == 0
@@ -229,10 +330,13 @@ def maxWeightMatching(edges, maxcardinality=False):
             base = blossombase[b]
             assert mate[base] >= 0
             assignLabel(endpoint[mate[base]], 1, mate[base] ^ 1)
+        log_return_procedure("assignLabel", call_id, context())
 
     # Trace back from vertices v and w to discover either a new blossom
     # or an augmenting path. Return the base vertex of the new blossom or -1.
     def scanBlossom(v, w):
+        call_id=log_fn_call("scanBlossom", context(), {"v":v,
+                                                       "w":w})
         if DEBUG: DEBUG('scanBlossom(%d,%d)' % (v, w))
         # Trace back from v and w, placing breadcrumbs as we go.
         path = [ ]
@@ -264,6 +368,7 @@ def maxWeightMatching(edges, maxcardinality=False):
        # Remove breadcrumbs.
         for b in path:
             label[b] = 1
+        log_return_fn("scanBlossom", call_id, context(), base)
         # Return base vertex, if we found one.
         return base
 
@@ -271,6 +376,8 @@ def maxWeightMatching(edges, maxcardinality=False):
     # connects a pair of S vertices. Label the new blossom as S; set its dual
     # variable to zero; relabel its T-vertices to S and add them to the queue.
     def addBlossom(base, k):
+        call_id=log_fn_call("addBlossom", context(), {"base":base,
+                                                      "k":k})
         (v, w, wt) = edges[k]
         bb = inblossom[base]
         bv = inblossom[v]
@@ -284,6 +391,7 @@ def maxWeightMatching(edges, maxcardinality=False):
         # Make list of sub-blossoms and their interconnecting edge endpoints.
         blossomchilds[b] = path = [ ]
         blossomendps[b] = endps = [ ]
+
         # Trace back from v to base.
         while bv != bb:
             # Add bv to the new blossom.
@@ -296,6 +404,7 @@ def maxWeightMatching(edges, maxcardinality=False):
             assert labelend[bv] >= 0
             v = endpoint[labelend[bv]]
             bv = inblossom[v]
+
         # Reverse lists, add endpoint that connects the pair of S vertices.
         path.append(bb)
         path.reverse()
@@ -313,6 +422,7 @@ def maxWeightMatching(edges, maxcardinality=False):
             assert labelend[bw] >= 0
             w = endpoint[labelend[bw]]
             bw = inblossom[w]
+
         # Set label to S.
         assert label[bb] == 1
         label[b] = 1
@@ -326,6 +436,7 @@ def maxWeightMatching(edges, maxcardinality=False):
                 # part of an S-blossom; add it to the queue.
                 queue.append(v)
             inblossom[v] = b
+
         # Compute blossombestedges[b].
         bestedgeto = (2 * nvertex) * [ -1 ]
         for bv in path:
@@ -350,6 +461,7 @@ def maxWeightMatching(edges, maxcardinality=False):
             # Forget about least-slack edges of the subblossom.
             blossombestedges[bv] = None
             bestedge[bv] = -1
+
         blossombestedges[b] = [ k for k in bestedgeto if k != -1 ]
         # Select bestedge[b].
         bestedge[b] = -1
@@ -357,10 +469,13 @@ def maxWeightMatching(edges, maxcardinality=False):
             if bestedge[b] == -1 or slack(k) < slack(bestedge[b]):
                 bestedge[b] = k
         if DEBUG: DEBUG('blossomchilds[%d]=' % b + repr(blossomchilds[b]))
+        log_return_procedure("addBlossom", call_id, context(), { 'blossombestedges':blossombestedges[b],
+                                                                 'bestedge':bestedge[b],
+                                                                 'slack':slack(bestedge[b])})
 
-    # Expand the given top-level blossom.
-    def expandBlossom(b, endstage):
-        if DEBUG: DEBUG('expandBlossom(%d,%d) %s' % (b, endstage, repr(blossomchilds[b])))
+    def promoteSubBlossomsToTopBlossoms(b, endstage):
+        call_id=log_fn_call("promoteSubBlossomsToTopBlossoms", context(), {"b":b,
+                                                                           "endstage":endstage})
         # Convert sub-blossoms into top-level blossoms.
         for s in blossomchilds[b]:
             blossomparent[s] = -1
@@ -372,82 +487,135 @@ def maxWeightMatching(edges, maxcardinality=False):
             else:
                 for v in blossomLeaves(s):
                     inblossom[v] = s
+        log_return_procedure("promoteSubBlossomsToTopBlossoms", call_id, context(), {})
+
+    def moveToBaseRelabeling(b):
+        call_id=log_fn_call("moveToBaseRelabeling", context(), {"b":b})
+        # Start at the sub-blossom through which the expanding
+        # blossom obtained its label, and relabel sub-blossoms untili
+        # we reach the base.
+        # Figure out through which sub-blossom the expanding blossom
+        # obtained its label initially.
+        assert labelend[b] >= 0
+        p = labelend[b]
+        entrychild = inblossom[endpoint[labelend[b] ^ 1]]
+        # Decide in which direction we will go round the blossom.
+        j = blossomchilds[b].index(entrychild)
+        indexes=[]
+        if j & 1:
+            # Start index is odd; go forward and wrap.
+            j -= len(blossomchilds[b])
+            jstep = 1
+            endptrick = 0
+        else:
+            # Start index is even; go backward.
+            jstep = -1
+            endptrick = 1
+        # Move along the blossom until we get to the base.
+        while j != 0:
+            # Relabel the T-sub-blossom.
+            label[endpoint[p ^ 1]] = 0
+            label[endpoint[blossomendps[b][j-endptrick]^endptrick^1]] = 0
+            assignLabel(endpoint[p ^ 1], 2, p)
+            # Step to the next S-sub-blossom and note its forward endpoint.
+            # indexes.append({"v1":blossomendps[b][j-endptrick]//2,
+            #                 "b":b,
+            #                 "j":j,
+            #                 "endptrick":endptrick})
+            allowedge[blossomendps[b][j-endptrick]//2] = True
+            j += jstep
+            p = blossomendps[b][j-endptrick] ^ endptrick
+            # Step to the next T-sub-blossom.
+            # indexes.append({"v1":p//2,
+            #                 "p":p,
+            #                 "j":j})
+            allowedge[p//2] = True
+            j += jstep
+        # Relabel the base T-sub-blossom WITHOUT stepping through to
+        # its mate (so don't call assignLabel).
+        bv = blossomchilds[b][0]
+        label[endpoint[p ^ 1]] = label[bv] = 2
+        labelend[endpoint[p ^ 1]] = labelend[bv] = p
+        bestedge[bv] = -1
+        log_return_procedure("moveToBaseRelabeling", call_id, context(), {})
+
+    def moveBackToEntryChildRelabeling(b):
+        call_id=log_fn_call("moveBackToEntryChildRelabeling", context(), {"b":b})
+        # Start at the sub-blossom through which the expanding
+        # blossom obtained its label, and relabel sub-blossoms untili
+        # we reach the base.
+        # Figure out through which sub-blossom the expanding blossom
+        # obtained its label initially.
+        assert labelend[b] >= 0
+        entrychild = inblossom[endpoint[labelend[b] ^ 1]]
+        # Decide in which direction we will go round the blossom.
+        j = blossomchilds[b].index(entrychild)
+        if j & 1:
+            # Start index is odd; go forward and wrap.
+            j = 1
+            jstep = 1
+            endptrick = 0
+        else:
+            # Start index is even; go backward.
+            j = -1
+            jstep = -1
+            endptrick = 1
+        ret_log=[]
+        # Continue along the blossom until we get back to entrychild.
+        while blossomchilds[b][j] != entrychild:
+            # Examine the vertices of the sub-blossom to see whether
+            # it is reachable from a neighbouring S-vertex outside the
+            # expanding blossom.
+            bv = blossomchilds[b][j]
+            if label[bv] == 1:
+                # This sub-blossom just got label S through one of its
+                # neighbours; leave it.
+                j += jstep
+                continue
+            ret_log.append({"leaves":list(blossomLeaves(bv))})
+            for v in blossomLeaves(bv):
+                if label[v] != 0:
+                    ret_log.append({"break":True,
+                                    "v":v})
+                    break
+            ret_log.append({"v":v})
+            # If the sub-blossom contains a reachable vertex, assign
+            # label T to the sub-blossom.
+            if label[v] != 0:
+                assert label[v] == 2
+                assert inblossom[v] == bv
+                label[v] = 0
+                label[endpoint[mate[blossombase[bv]]]] = 0
+                assignLabel(v, 2, labelend[v])
+            j += jstep
+        log_return_procedure("moveBackToEntryChildRelabeling", call_id, context(), {"ret_log":ret_log})
+
+    # Expand the given top-level blossom.
+    def expandBlossom(b, endstage):
+        call_id=log_fn_call("expandBlossom", context(), {"b":b,
+                                                         "endstage":endstage})
+        if DEBUG: DEBUG('expandBlossom(%d,%d) %s' % (b, endstage, repr(blossomchilds[b])))
+        promoteSubBlossomsToTopBlossoms(b, endstage)
         # If we expand a T-blossom during a stage, its sub-blossoms must be
         # relabeled.
         if (not endstage) and label[b] == 2:
-            # Start at the sub-blossom through which the expanding
-            # blossom obtained its label, and relabel sub-blossoms untili
-            # we reach the base.
-            # Figure out through which sub-blossom the expanding blossom
-            # obtained its label initially.
-            assert labelend[b] >= 0
-            entrychild = inblossom[endpoint[labelend[b] ^ 1]]
-            # Decide in which direction we will go round the blossom.
-            j = blossomchilds[b].index(entrychild)
-            if j & 1:
-                # Start index is odd; go forward and wrap.
-                j -= len(blossomchilds[b])
-                jstep = 1
-                endptrick = 0
-            else:
-                # Start index is even; go backward.
-                jstep = -1
-                endptrick = 1
-            # Move along the blossom until we get to the base.
-            p = labelend[b]
-            while j != 0:
-                # Relabel the T-sub-blossom.
-                label[endpoint[p ^ 1]] = 0
-                label[endpoint[blossomendps[b][j-endptrick]^endptrick^1]] = 0
-                assignLabel(endpoint[p ^ 1], 2, p)
-                # Step to the next S-sub-blossom and note its forward endpoint.
-                allowedge[blossomendps[b][j-endptrick]//2] = True
-                j += jstep
-                p = blossomendps[b][j-endptrick] ^ endptrick
-                # Step to the next T-sub-blossom.
-                allowedge[p//2] = True
-                j += jstep
-            # Relabel the base T-sub-blossom WITHOUT stepping through to
-            # its mate (so don't call assignLabel).
-            bv = blossomchilds[b][j]
-            label[endpoint[p ^ 1]] = label[bv] = 2
-            labelend[endpoint[p ^ 1]] = labelend[bv] = p
-            bestedge[bv] = -1
-            # Continue along the blossom until we get back to entrychild.
-            j += jstep
-            while blossomchilds[b][j] != entrychild:
-                # Examine the vertices of the sub-blossom to see whether
-                # it is reachable from a neighbouring S-vertex outside the
-                # expanding blossom.
-                bv = blossomchilds[b][j]
-                if label[bv] == 1:
-                    # This sub-blossom just got label S through one of its
-                    # neighbours; leave it.
-                    j += jstep
-                    continue
-                for v in blossomLeaves(bv):
-                    if label[v] != 0:
-                        break
-                # If the sub-blossom contains a reachable vertex, assign
-                # label T to the sub-blossom.
-                if label[v] != 0:
-                    assert label[v] == 2
-                    assert inblossom[v] == bv
-                    label[v] = 0
-                    label[endpoint[mate[blossombase[bv]]]] = 0
-                    assignLabel(v, 2, labelend[v])
-                j += jstep
+            moveToBaseRelabeling(b)
+            moveBackToEntryChildRelabeling(b)
         # Recycle the blossom number.
-        label[b] = labelend[b] = -1
+        label[b] = 0
+        labelend[b] = -1
         blossomchilds[b] = blossomendps[b] = None
         blossombase[b] = -1
         blossombestedges[b] = None
         bestedge[b] = -1
         unusedblossoms.append(b)
+        log_return_procedure("expandBlossom", call_id, context(), {})
 
     # Swap matched/unmatched edges over an alternating path through blossom b
     # between vertex v and the base vertex. Keep blossom bookkeeping consistent.
     def augmentBlossom(b, v):
+        call_id=log_fn_call("augmentBlossom", context(), {"b":b,
+                                                          "v":v})
         if DEBUG: DEBUG('augmentBlossom(%d,%d)' % (b, v))
         # Bubble up through the blossom tree from vertex v to an immediate
         # sub-blossom of b.
@@ -459,6 +627,7 @@ def maxWeightMatching(edges, maxcardinality=False):
             augmentBlossom(t, v)
         # Decide in which direction we will go round the blossom.
         i = j = blossomchilds[b].index(t)
+
         if i & 1:
             # Start index is odd; go forward and wrap.
             j -= len(blossomchilds[b])
@@ -468,6 +637,7 @@ def maxWeightMatching(edges, maxcardinality=False):
             # Start index is even; go backward.
             jstep = -1
             endptrick = 1
+
         # Move along the blossom until we get to the base.
         while j != 0:
             # Step to the next sub-blossom and augment it recursively.
@@ -485,16 +655,19 @@ def maxWeightMatching(edges, maxcardinality=False):
             mate[endpoint[p]] = p ^ 1
             mate[endpoint[p ^ 1]] = p
             if DEBUG: DEBUG('PAIR %d %d (k=%d)' % (endpoint[p], endpoint[p^1], p//2))
+
         # Rotate the list of sub-blossoms to put the new base at the front.
         blossomchilds[b] = blossomchilds[b][i:] + blossomchilds[b][:i]
         blossomendps[b]  = blossomendps[b][i:]  + blossomendps[b][:i]
         blossombase[b] = blossombase[blossomchilds[b][0]]
         assert blossombase[b] == v
+        log_return_procedure("augmentBlossom", call_id, context())
 
     # Swap matched/unmatched edges over an alternating path between two
     # single vertices. The augmenting path runs through edge k, which
     # connects a pair of S vertices.
     def augmentMatching(k):
+        call_id=log_fn_call("augmentMatching", context(), {"k":k})
         (v, w, wt) = edges[k]
         if DEBUG: DEBUG('augmentMatching(%d) (v=%d w=%d)' % (k, v, w))
         if DEBUG: DEBUG('PAIR %d %d (k=%d)' % (v, w, k))
@@ -532,9 +705,12 @@ def maxWeightMatching(edges, maxcardinality=False):
                 # it will be assigned to mate[s] in the next step.
                 p = labelend[bt] ^ 1
                 if DEBUG: DEBUG('PAIR %d %d (k=%d)' % (s, t, p//2))
+        log_return_procedure("augmentMatching", call_id, context())
 
     # Verify that the optimum solution has been reached.
     def verifyOptimum():
+        call_id=log_fn_call("verifyOptimum", context(), {})
+        problems = []
         if maxcardinality:
             # Vertices may have negative dual;
             # find a constant non-negative number to add to all vertex duals.
@@ -542,8 +718,13 @@ def maxWeightMatching(edges, maxcardinality=False):
         else:
             vdualoffset = 0
         # 0. all dual variables are non-negative
-        assert min(dualvar[:nvertex]) + vdualoffset >= 0
-        assert min(dualvar[nvertex:]) >= 0
+        if not min(dualvar[:nvertex]) + vdualoffset >= 0:
+            problems.append({"type":"invalid-dual-vars",
+                             "min-dual": min(dualvar[:nvertex]),
+                             "vdual-offset": vdualoffset})
+        if not min(dualvar[nvertex:]) >= 0:
+            problems.append({"type":"invalid-dual-vars",
+                             "min-dual-blossoms": min(dualvar[nvertex:])})
         # 0. all edges have non-negative slack and
         # 1. all matched edges have zero slack;
         for k in range(nedge):
@@ -561,21 +742,54 @@ def maxWeightMatching(edges, maxcardinality=False):
                 if bi != bj:
                     break
                 s += 2 * dualvar[bi]
-            assert s >= 0
-            if mate[i] // 2 == k or mate[j] // 2 == k:
-                assert mate[i] // 2 == k and mate[j] // 2 == k
-                assert s == 0
+            if s < 0 or ( mate[i] // 2 == k and mate[j] // 2 == k and s != 0 ):
+                problems.append({"type":"invalid-edge-slack",
+                                 "edge":edges[k],
+                                 "weight":wt,
+                                 "mate":mate,
+                                 "slack":s})
+            elif ( mate[i] // 2 == k and mate[j] // 2 != k ) or ( mate[j] // 2 == k and mate[i] // 2 != k ):
+                problems.append({"type":"invalid-mate",
+                                 "k":k,
+                                 "matei":mate[i] // 2,
+                                 "matej":mate[j] // 2,
+                                 "edge":edges[k],
+                                 "weight":wt,
+                                 "mate":mate,
+                                 "slack":s})
+            # assert s >= 0
+            # if mate[i] // 2 == k or mate[j] // 2 == k:
+            #     assert mate[i] // 2 == k and mate[j] // 2 == k
+            #     assert s == 0
+
         # 2. all single vertices have zero dual value;
         for v in range(nvertex):
-            assert mate[v] >= 0 or dualvar[v] + vdualoffset == 0
+            if not ( mate[v] >= 0 or dualvar[v] + vdualoffset == 0 ):
+                problems.append({"type":"invalid-gnodes",
+                                 "v":v,
+                                 "mate-v":mate[v],
+                                 "dual-v":dualvar[v],
+                                 "vdual-offset":vdualoffset})
+            # assert mate[v] >= 0 or dualvar[v] + vdualoffset == 0
         # 3. all blossoms with positive dual value are full.
         for b in range(nvertex, 2*nvertex):
             if blossombase[b] >= 0 and dualvar[b] > 0:
-                assert len(blossomendps[b]) % 2 == 1
+                invalid = False
+                if not ( len(blossomendps[b]) % 2 == 1 ):
+                    invalid = True
+                # assert len(blossomendps[b]) % 2 == 1
                 for p in blossomendps[b][1::2]:
-                    assert mate[endpoint[p]] == p ^ 1
-                    assert mate[endpoint[p ^ 1]] == p
+                    if mate[endpoint[p]] != p ^ 1 or mate[endpoint[p ^ 1]] != p:
+                        invalid = True
+                        break
+                    # assert mate[endpoint[p]] == p ^ 1
+                    # assert mate[endpoint[p ^ 1]] == p
+                if invalid:
+                    problems.append({"type":"invalid-blossom-not-full",
+                                     "b":b})
         # Ok.
+        log_return_fn("verifyOptimum", call_id, context(), problems)
+        return problems
 
     # Check optimized delta2 against a trivial computation.
     def checkDelta2():
@@ -624,6 +838,174 @@ def maxWeightMatching(edges, maxcardinality=False):
             DEBUG('bk=%d tbk=%d bd=%s tbd=%s' % (bk, tbk, repr(bd), repr(tbd)))
         assert bd == tbd
 
+    def expandSblossomsWithZeroDual():
+        call_id=log_fn_call("expandSblossomsWithZeroDual", context(), {})
+        for b in range(nvertex, 2*nvertex):
+            if ( blossomparent[b] == -1 and blossombase[b] >= 0 and
+                 label[b] == 1 and dualvar[b] == 0 ):
+                expandBlossom(b, True)
+        log_return_procedure("expandSblossomsWithZeroDual", call_id, context())
+
+    def scanNeighbors(v):
+        call_id=log_fn_call("scanNeighbors", context(), {'v': v})
+        augmented = 0
+        # Scan its neighbours:
+        for p in neighbend[v]:
+            k = p // 2
+            w = endpoint[p]
+            # w is a neighbour to v
+            if inblossom[v] == inblossom[w]:
+                # this edge is internal to a blossom; ignore it
+                continue
+            if not allowedge[k]:
+                kslack = slack(k)
+                if kslack <= 0:
+                    # edge k has zero slack => it is allowable
+                    allowedge[k] = True
+            if allowedge[k]:
+                if label[inblossom[w]] == 0:
+                    # (C1) w is a free vertex;
+                    # label w with T and label its mate with S (R12).
+                    assignLabel(w, 2, p ^ 1)
+                elif label[inblossom[w]] == 1:
+                    # (C2) w is an S-vertex (not in the same blossom);
+                    # follow back-links to discover either an
+                    # augmenting path or a new blossom.
+                    base = scanBlossom(v, w)
+                    if base >= 0:
+                        # Found a new blossom; add it to the blossom
+                        # bookkeeping and turn it into an S-blossom.
+                        addBlossom(base, k)
+                    else:
+                        # Found an augmenting path; augment the
+                        # matching and end this stage.
+                        augmentMatching(k)
+                        augmented = 1
+                        break
+                elif label[w] == 0:
+                    # w is inside a T-blossom, but w itself has not
+                    # yet been reached from outside the blossom;
+                    # mark it as reached (we need this to relabel
+                    # during T-blossom expansion).
+                    assert label[inblossom[w]] == 2
+                    label[w] = 2
+                    labelend[w] = p ^ 1
+            elif label[inblossom[w]] == 1:
+                # keep track of the least-slack non-allowable edge to
+                # a different S-blossom.
+                b = inblossom[v]
+                if bestedge[b] == -1 or kslack < slack(bestedge[b]):
+                    bestedge[b] = k
+            elif label[w] == 0:
+                # w is a free vertex (or an unreached vertex inside
+                # a T-blossom) but we can not reach it yet;
+                # keep track of the least-slack edge that reaches w.
+                if bestedge[w] == -1 or kslack < slack(bestedge[w]):
+                    bestedge[w] = k
+        log_return_fn("scanNeighbors", call_id, context(), augmented)
+        return augmented
+
+    def findAugmentingPath():
+        call_id=log_fn_call("findAugmentingPath", context(), {})
+        augmented=0
+        while queue and not augmented:
+            # Take an S vertex from the queue.
+            v = queue.pop()
+            assert label[inblossom[v]] == 1
+
+            # Scan its neighbours:
+            augmented = scanNeighbors(v)
+        log_return_fn("findAugmentingPath", call_id, context(), augmented)
+        return augmented
+
+    def computeDelta():
+        call_id=log_fn_call("computeDelta", context(), {})
+        # There is no augmenting path under these constraints;
+        # compute delta and reduce slack in the optimization problem.
+        # (Note that our vertex dual variables, edge slacks and delta's
+        # are pre-multiplied by two.)
+        deltatype = -1
+        delta = deltaedge = deltablossom = None
+
+        # Verify data structures for delta2/delta3 computation.
+        if CHECK_DELTA:
+            checkDelta2()
+            checkDelta3()
+
+        # Compute delta1: the minumum value of any vertex dual.
+        if not maxcardinality:
+            deltatype = 1
+            delta = min(dualvar[:nvertex])
+
+        # Compute delta2: the minimum slack on any edge between
+        # an S-vertex and a free vertex.
+        for v in range(nvertex):
+            if label[inblossom[v]] == 0 and bestedge[v] != -1:
+                d = slack(bestedge[v])
+                if deltatype == -1 or d < delta:
+                    delta = d
+                    deltatype = 2
+                    deltaedge = bestedge[v]
+
+        # Compute delta3: half the minimum slack on any edge between
+        # a pair of S-blossoms.
+        for b in range(2 * nvertex):
+            if ( blossomparent[b] == -1 and label[b] == 1 and
+                 bestedge[b] != -1 ):
+                kslack = slack(bestedge[b])
+                if isinstance(kslack, integer_types):
+                    assert (kslack % 2) == 0
+                    d = kslack // 2
+                else:
+                    d = kslack / 2
+                if deltatype == -1 or d < delta:
+                    delta = d
+                    deltatype = 3
+                    deltaedge = bestedge[b]
+
+        # Compute delta4: minimum z variable of any T-blossom.
+        for b in range(nvertex, 2*nvertex):
+            if ( blossombase[b] >= 0 and blossomparent[b] == -1 and
+                 label[b] == 2 and
+                 (deltatype == -1 or dualvar[b] < delta) ):
+                delta = dualvar[b]
+                deltatype = 4
+                deltablossom = b
+
+        if deltatype == -1:
+            # No further improvement possible; max-cardinality optimum
+            # reached. Do a final delta update to make the optimum
+            # verifyable.
+            assert maxcardinality
+            deltatype = 1
+            delta = max(0, min(dualvar[:nvertex]))
+
+        # Update dual variables according to delta.
+        for v in range(nvertex):
+            if label[inblossom[v]] == 1:
+                # S-vertex: 2*u = 2*u - 2*delta
+                dualvar[v] -= delta
+            elif label[inblossom[v]] == 2:
+                # T-vertex: 2*u = 2*u + 2*delta
+                dualvar[v] += delta
+        for b in range(nvertex, 2*nvertex):
+            if blossombase[b] >= 0 and blossomparent[b] == -1:
+                if label[b] == 1:
+                    # top-level S-blossom: z = z + 2*delta
+                    dualvar[b] += delta
+                elif label[b] == 2:
+                    # top-level T-blossom: z = z - 2*delta
+                    dualvar[b] -= delta
+
+        ret = {"delta":delta,
+               "delta-type":deltatype}
+        if deltatype == 2 or deltatype == 3:
+            ret["delta-edge"]=deltaedge
+        if deltatype == 4:
+            ret["delta-blossom"]=deltablossom
+        log_return_fn("computeDelta", call_id, context(), ret)
+        return ret
+
     # Main loop: continue until no further improvement is possible.
     for t in range(nvertex):
 
@@ -665,152 +1047,22 @@ def maxWeightMatching(edges, maxcardinality=False):
 
             # Continue labeling until all vertices which are reachable
             # through an alternating path have got a label.
-            while queue and not augmented:
-
-                # Take an S vertex from the queue.
-                v = queue.pop()
-                if DEBUG: DEBUG('POP v=%d' % v)
-                assert label[inblossom[v]] == 1
-
-                # Scan its neighbours:
-                for p in neighbend[v]:
-                    k = p // 2
-                    w = endpoint[p]
-                    # w is a neighbour to v
-                    if inblossom[v] == inblossom[w]:
-                        # this edge is internal to a blossom; ignore it
-                        continue
-                    if not allowedge[k]:
-                        kslack = slack(k)
-                        if kslack <= 0:
-                            # edge k has zero slack => it is allowable
-                            allowedge[k] = True
-                    if allowedge[k]:
-                        if label[inblossom[w]] == 0:
-                            # (C1) w is a free vertex;
-                            # label w with T and label its mate with S (R12).
-                            assignLabel(w, 2, p ^ 1)
-                        elif label[inblossom[w]] == 1:
-                            # (C2) w is an S-vertex (not in the same blossom);
-                            # follow back-links to discover either an
-                            # augmenting path or a new blossom.
-                            base = scanBlossom(v, w)
-                            if base >= 0:
-                                # Found a new blossom; add it to the blossom
-                                # bookkeeping and turn it into an S-blossom.
-                                addBlossom(base, k)
-                            else:
-                                # Found an augmenting path; augment the
-                                # matching and end this stage.
-                                augmentMatching(k)
-                                augmented = 1
-                                break
-                        elif label[w] == 0:
-                            # w is inside a T-blossom, but w itself has not
-                            # yet been reached from outside the blossom;
-                            # mark it as reached (we need this to relabel
-                            # during T-blossom expansion).
-                            assert label[inblossom[w]] == 2
-                            label[w] = 2
-                            labelend[w] = p ^ 1
-                    elif label[inblossom[w]] == 1:
-                        # keep track of the least-slack non-allowable edge to
-                        # a different S-blossom.
-                        b = inblossom[v]
-                        if bestedge[b] == -1 or kslack < slack(bestedge[b]):
-                            bestedge[b] = k
-                    elif label[w] == 0:
-                        # w is a free vertex (or an unreached vertex inside
-                        # a T-blossom) but we can not reach it yet;
-                        # keep track of the least-slack edge that reaches w.
-                        if bestedge[w] == -1 or kslack < slack(bestedge[w]):
-                            bestedge[w] = k
+            augmented = findAugmentingPath()
 
             if augmented:
                 break
 
-            # There is no augmenting path under these constraints;
-            # compute delta and reduce slack in the optimization problem.
-            # (Note that our vertex dual variables, edge slacks and delta's
-            # are pre-multiplied by two.)
-            deltatype = -1
-            delta = deltaedge = deltablossom = None
-
-            # Verify data structures for delta2/delta3 computation.
-            if CHECK_DELTA:
-                checkDelta2()
-                checkDelta3()
-
-            # Compute delta1: the minumum value of any vertex dual.
-            if not maxcardinality:
-                deltatype = 1
-                delta = min(dualvar[:nvertex])
-
-            # Compute delta2: the minimum slack on any edge between
-            # an S-vertex and a free vertex.
-            for v in range(nvertex):
-                if label[inblossom[v]] == 0 and bestedge[v] != -1:
-                    d = slack(bestedge[v])
-                    if deltatype == -1 or d < delta:
-                        delta = d
-                        deltatype = 2
-                        deltaedge = bestedge[v]
-
-            # Compute delta3: half the minimum slack on any edge between
-            # a pair of S-blossoms.
-            for b in range(2 * nvertex):
-                if ( blossomparent[b] == -1 and label[b] == 1 and
-                     bestedge[b] != -1 ):
-                    kslack = slack(bestedge[b])
-                    if isinstance(kslack, integer_types):
-                        assert (kslack % 2) == 0
-                        d = kslack // 2
-                    else:
-                        d = kslack / 2
-                    if deltatype == -1 or d < delta:
-                        delta = d
-                        deltatype = 3
-                        deltaedge = bestedge[b]
-
-            # Compute delta4: minimum z variable of any T-blossom.
-            for b in range(nvertex, 2*nvertex):
-                if ( blossombase[b] >= 0 and blossomparent[b] == -1 and
-                     label[b] == 2 and
-                     (deltatype == -1 or dualvar[b] < delta) ):
-                    delta = dualvar[b]
-                    deltatype = 4
-                    deltablossom = b
-
-            if deltatype == -1:
-                # No further improvement possible; max-cardinality optimum
-                # reached. Do a final delta update to make the optimum
-                # verifyable.
-                assert maxcardinality
-                deltatype = 1
-                delta = max(0, min(dualvar[:nvertex]))
-
-            # Update dual variables according to delta.
-            for v in range(nvertex):
-                if label[inblossom[v]] == 1:
-                    # S-vertex: 2*u = 2*u - 2*delta
-                    dualvar[v] -= delta
-                elif label[inblossom[v]] == 2:
-                    # T-vertex: 2*u = 2*u + 2*delta
-                    dualvar[v] += delta
-            for b in range(nvertex, 2*nvertex):
-                if blossombase[b] >= 0 and blossomparent[b] == -1:
-                    if label[b] == 1:
-                        # top-level S-blossom: z = z + 2*delta
-                        dualvar[b] += delta
-                    elif label[b] == 2:
-                        # top-level T-blossom: z = z - 2*delta
-                        dualvar[b] -= delta
+            primaldual = computeDelta()
+            noimprovementpossible = 0
+            deltatype = primaldual["delta-type"]
+            deltaedge = primaldual.get("delta-edge")
+            deltablossom = primaldual.get("delta-blossom")
 
             # Take action at the point where minimum delta occurred.
-            if DEBUG: DEBUG('delta%d=%f' % (deltatype, delta))
-            if deltatype == 1: 
+            # if DEBUG: DEBUG('delta%d=%f' % (deltatype, delta))
+            if deltatype == 1:
                 # No further improvement possible; optimum reached.
-                break
+                noimprovementpossible = 1
             elif deltatype == 2:
                 # Use the least-slack edge to continue the search.
                 allowedge[deltaedge] = True
@@ -829,21 +1081,30 @@ def maxWeightMatching(edges, maxcardinality=False):
                 # Expand the least-z blossom.
                 expandBlossom(deltablossom, False)
 
+            if noimprovementpossible:
+                break
+
             # End of a this substage.
 
         # Stop when no more augmenting path can be found.
         if not augmented:
             break
+        else:
+            verify = verifyOptimum()
+            if verify and DEBUG:
+                DEBUG('verify: {}'.format(verify))
 
         # End of a stage; expand all S-blossoms which have dualvar = 0.
-        for b in range(nvertex, 2*nvertex):
-            if ( blossomparent[b] == -1 and blossombase[b] >= 0 and
-                 label[b] == 1 and dualvar[b] == 0 ):
-                expandBlossom(b, True)
+        expandSblossomsWithZeroDual()
 
     # Verify that we reached the optimum solution.
     if CHECK_OPTIMUM:
-        verifyOptimum()
+        verify = verifyOptimum()
+        if verify:
+            raise Exception("Invalid optimum check, it should be empty: {}".format(verify))
+
+    # save the context value before mate[] is transformed to match clojure implementation
+    ctx = context()
 
     # Transform mate[] such that mate[v] is the vertex to which v is paired.
     for v in range(nvertex):
@@ -852,6 +1113,7 @@ def maxWeightMatching(edges, maxcardinality=False):
     for v in range(nvertex):
         assert mate[v] == -1 or mate[mate[v]] == v
 
+    log_return_fn("maxWeightMatching", call_id, ctx, mate)
     return mate
 
 
@@ -864,80 +1126,112 @@ if __name__ == '__main__':
         def test10_empty(self):
             # empty input graph
             self.assertEqual(maxWeightMatching([]), [])
+            write_log(OUTPUT_DIR + "10_empty.json")
 
         def test11_singleedge(self):
             # single edge
             self.assertEqual(maxWeightMatching([ (0,1,1) ]), [1, 0])
+            write_log(OUTPUT_DIR + "11_singleedge.json")
 
         def test12(self):
             self.assertEqual(maxWeightMatching([ (1,2,10), (2,3,11) ]), [ -1, -1, 3, 2 ])
+            write_log(OUTPUT_DIR + "12.json")
 
         def test13(self):
             self.assertEqual(maxWeightMatching([ (1,2,5), (2,3,11), (3,4,5) ]), [ -1, -1, 3, 2, -1 ])
+            write_log(OUTPUT_DIR + "13.json")
 
         def test14_maxcard(self):
             # maximum cardinality
             self.assertEqual(maxWeightMatching([ (1,2,5), (2,3,11), (3,4,5) ], True), [ -1, 2, 1, 4, 3 ])
+            write_log(OUTPUT_DIR + "14_maxcard.json")
 
         def test15_float(self):
             # floating point weigths
             self.assertEqual(maxWeightMatching([ (1,2,math.pi), (2,3,math.exp(1)), (1,3,3.0), (1,4,math.sqrt(2.0)) ]), [ -1, 4, 3, 2, 1 ])
+            write_log(OUTPUT_DIR + "15_float.json")
 
         def test16_negative(self):
             # negative weights
             self.assertEqual(maxWeightMatching([ (1,2,2), (1,3,-2), (2,3,1), (2,4,-1), (3,4,-6) ], False), [ -1, 2, 1, -1, -1 ])
             self.assertEqual(maxWeightMatching([ (1,2,2), (1,3,-2), (2,3,1), (2,4,-1), (3,4,-6) ], True), [ -1, 3, 4, 1, 2 ])
+            write_log(OUTPUT_DIR + "16_negative.json")
 
         def test20_sblossom(self):
             # create S-blossom and use it for augmentation
             self.assertEqual(maxWeightMatching([ (1,2,8), (1,3,9), (2,3,10), (3,4,7) ]), [ -1, 2, 1, 4, 3 ])
             self.assertEqual(maxWeightMatching([ (1,2,8), (1,3,9), (2,3,10), (3,4,7), (1,6,5), (4,5,6) ]), [ -1, 6, 3, 2, 5, 4, 1 ])
+            write_log(OUTPUT_DIR + "20_sblossom.json")
 
         def test21_tblossom(self):
             # create S-blossom, relabel as T-blossom, use for augmentation
             self.assertEqual(maxWeightMatching([ (1,2,9), (1,3,8), (2,3,10), (1,4,5), (4,5,4), (1,6,3) ]), [ -1, 6, 3, 2, 5, 4, 1 ])
             self.assertEqual(maxWeightMatching([ (1,2,9), (1,3,8), (2,3,10), (1,4,5), (4,5,3), (1,6,4) ]), [ -1, 6, 3, 2, 5, 4, 1 ])
             self.assertEqual(maxWeightMatching([ (1,2,9), (1,3,8), (2,3,10), (1,4,5), (4,5,3), (3,6,4) ]), [ -1, 2, 1, 6, 5, 4, 3 ])
+            write_log(OUTPUT_DIR + "21_tblossom.json")
 
         def test22_s_nest(self):
             # create nested S-blossom, use for augmentation
             self.assertEqual(maxWeightMatching([ (1,2,9), (1,3,9), (2,3,10), (2,4,8), (3,5,8), (4,5,10), (5,6,6) ]), [ -1, 3, 4, 1, 2, 6, 5 ])
+            write_log(OUTPUT_DIR + "22_s_nest.json")
 
         def test23_s_relabel_nest(self):
             # create S-blossom, relabel as S, include in nested S-blossom
             self.assertEqual(maxWeightMatching([ (1,2,10), (1,7,10), (2,3,12), (3,4,20), (3,5,20), (4,5,25), (5,6,10), (6,7,10), (7,8,8) ]), [ -1, 2, 1, 4, 3, 6, 5, 8, 7 ])
+            write_log(OUTPUT_DIR + "23_s_relabel_nest.json")
 
         def test24_s_nest_expand(self):
             # create nested S-blossom, augment, expand recursively
             self.assertEqual(maxWeightMatching([ (1,2,8), (1,3,8), (2,3,10), (2,4,12), (3,5,12), (4,5,14), (4,6,12), (5,7,12), (6,7,14), (7,8,12) ]), [ -1, 2, 1, 5, 6, 3, 4, 8, 7 ])
+            write_log(OUTPUT_DIR + "24_s_nest_expand.json")
 
         def test25_s_t_expand(self):
             # create S-blossom, relabel as T, expand
             self.assertEqual(maxWeightMatching([ (1,2,23), (1,5,22), (1,6,15), (2,3,25), (3,4,22), (4,5,25), (4,8,14), (5,7,13) ]), [ -1, 6, 3, 2, 8, 7, 1, 5, 4 ])
+            write_log(OUTPUT_DIR + "25_s_t_expand.json")
 
         def test26_s_nest_t_expand(self):
             # create nested S-blossom, relabel as T, expand
             self.assertEqual(maxWeightMatching([ (1,2,19), (1,3,20), (1,8,8), (2,3,25), (2,4,18), (3,5,18), (4,5,13), (4,7,7), (5,6,7) ]), [ -1, 8, 3, 2, 7, 6, 5, 4, 1 ])
+            write_log(OUTPUT_DIR + "26_s_nest_t_expand.json")
 
         def test30_tnasty_expand(self):
             # create blossom, relabel as T in more than one way, expand, augment
             self.assertEqual(maxWeightMatching([ (1,2,45), (1,5,45), (2,3,50), (3,4,45), (4,5,50), (1,6,30), (3,9,35), (4,8,35), (5,7,26), (9,10,5) ]), [ -1, 6, 3, 2, 8, 7, 1, 5, 4, 10, 9 ])
+            write_log(OUTPUT_DIR + "30_tnasty_expand.json")
 
         def test31_tnasty2_expand(self):
             # again but slightly different
             self.assertEqual(maxWeightMatching([ (1,2,45), (1,5,45), (2,3,50), (3,4,45), (4,5,50), (1,6,30), (3,9,35), (4,8,26), (5,7,40), (9,10,5) ]), [ -1, 6, 3, 2, 8, 7, 1, 5, 4, 10, 9 ])
+            write_log(OUTPUT_DIR + "31_tnasty2_expand.json")
 
         def test32_t_expand_leastslack(self):
             # create blossom, relabel as T, expand such that a new least-slack S-to-free edge is produced, augment
             self.assertEqual(maxWeightMatching([ (1,2,45), (1,5,45), (2,3,50), (3,4,45), (4,5,50), (1,6,30), (3,9,35), (4,8,28), (5,7,26), (9,10,5) ]), [ -1, 6, 3, 2, 8, 7, 1, 5, 4, 10, 9 ])
+            write_log(OUTPUT_DIR + "32_t_expand_leastslack.json")
 
         def test33_nest_tnasty_expand(self):
             # create nested blossom, relabel as T in more than one way, expand outer blossom such that inner blossom ends up on an augmenting path
             self.assertEqual(maxWeightMatching([ (1,2,45), (1,7,45), (2,3,50), (3,4,45), (4,5,95), (4,6,94), (5,6,94), (6,7,50), (1,8,30), (3,11,35), (5,9,36), (7,10,26), (11,12,5) ]), [ -1, 8, 3, 2, 6, 9, 4, 10, 1, 5, 7, 12, 11 ])
+            write_log(OUTPUT_DIR + "33_nest_tnasty_expand.json")
 
         def test34_nest_relabel_expand(self):
             # create nested S-blossom, relabel as S, expand recursively
             self.assertEqual(maxWeightMatching([ (1,2,40), (1,3,40), (2,3,60), (2,4,55), (3,5,55), (4,5,50), (1,8,15), (5,7,30), (7,6,10), (8,10,10), (4,9,30) ]), [ -1, 2, 1, 5, 9, 3, 7, 6, 10, 4, 8 ])
+            write_log(OUTPUT_DIR + "34_nest_relabel_expand.json")
+
+        # def test35_large_file1(self):
+        #     with open('large_graph1.json') as json_file:
+        #         data=json.load(json_file)
+        #         self.assertEqual(maxWeightMatching(data), [54, 48, 26, 47, 23, 40, 42, 43, 27, 44, 36, 34, 16, 49, 22, 31, 12, 30, 38, 24, -1, 51, 14, 4, 19, 41, 2, 8, 53, 50, 17, 15, 46, 45, 11, 39, 10, 52, 18, 35, 5, 25, 6, 7, 9, 33, 32, 3, 1, 13, 29, 21, 37, 28, 0])
+        #     write_log(OUTPUT_DIR + "35_large_file1.json")
+
+        # def test36_large_file2(self):
+        #     with open('large_graph2.json') as json_file:
+        #         data=json.load(json_file)
+        #         self.assertEqual(maxWeightMatching(data), [3, 19, 25, 0, 20, -1, 9, 13, 14, 6, 26, 22, 27, 7, 8, 17, 28, 15, 21, 1, 4, 18, 11, 24, 23, 2, 10, 12, 16])
+        #     write_log(OUTPUT_DIR + "36_large_file2.json")
+
 
     CHECK_DELTA = True
     unittest.main()
